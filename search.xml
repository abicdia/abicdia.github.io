<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript精粹]]></title>
    <url>%2F2019%2F05%2F12%2Fjavascript%E7%B2%BE%E7%B2%B9%2F</url>
    <content type="text"><![CDATA[书中附录 A 不可避免的糟粕 B 可以避免的糟粕 C JSLint js解析器 下面列出的值被当假(falsy) false null undefined 空字符串 数字0 数字呢NaN（表示一个不能产生正常运算结果） typeof运算产生的值有(可以排除函数) number string boolean undefined function object 对象12345678var people = &#123; name: &quot;xiaowen&quot;&#125;var name = people.hh || &quot;unknow&quot;console.log(name);console.log(people.class.id); //Cannot read property &apos;id&apos; of undefinedconsole.log(people.class &amp;&amp; people.class.id); //undefined 尝试检索一个不存在的元素会返回undefined || 运算符可以用来填充默认值 检索undefined的值会报错，可以通过&amp;&amp;来避免错误 12var a=&#123;&#125;,b=&#123;&#125;,c=&#123;&#125;; //a,b,c每个都引用一个不同的空对象a=b=c=&#123;&#125;; //a,b,c每个都引用同一个空对象 对象是引用来传递的，不会被拷贝 1234567891011121314var people = &#123; name: &quot;xiaowen&quot;, hi: function() &#123; console.log(&quot;my name is &quot; + this.name); &#125;, id: &quot;233&quot;&#125;people.hi();for (name in people) &#123; if (typeof people[name] !== &apos;function&apos;) &#123; console.log(name); // name,id &#125;&#125; 5.可以用hasOwnProperty过滤属性，typeof排除函数 123456789101112var people = &#123; name: &quot;xiaowen&quot;, id:&quot;233&quot;, type:&quot;1&quot;&#125;var arr=[&quot;type&quot;,&quot;name&quot;,&quot;id&quot;]for(i=0;i&lt;arr.length;i++)&#123; console.log(people[arr[i]])&#125; 属性名出现的顺序是不确定的，如果你要的属性名以特定顺序出现，最好的办法是避免使用for in语句，用for，创建一个数组，在其以正确的顺序包含属性名。不用担心，可能发掘出原型链中的属性，并且我们按照正确的顺序取到了他们的值。 1var myApp=&#123;&#125; 减少使用全局变量，最小化使用全局变量的方法，在你应用中只创建一个唯一的全局变量。把多个全局变量都整理到一个名称空间下;使用闭包来进行信息隐藏 函数函数调用模式(?) 实参&gt;形参，超出的参数会被忽略； 形参&gt;实参,缺失的值会被替换成undefined； 方法调用模式 函数调用模式 构造器调用模式 apply调用模式 参数函数被调用的时候，会赠送一个arguments数组1234567891011var sum=function()&#123; var i,sum=0; for(i=0;i&lt;arguments.length;i+=1) &#123; sum+=arguments[i]; &#125; return sum;&#125; console.log(sum(1,2,3)) //6 return1.函数总会返回一个值，没有返回值，则返回undefined 异常1.throw123456789101112var add=function(a,b) &#123; if(typeof a!== &apos;number&apos; || typeof b!=&apos;number&apos;) &#123; throw &#123; name:&quot;typeerror&quot;, message:&apos;add needs numbers&apos; &#125; &#125; return console.log(a+b); &#125; add(1,&quot;jh&quot;); \\报错提示 2.try……catch123456789101112var try_it=function()&#123; try &#123; add(&apos;seven&apos;); &#125; catch(e) &#123; console.log(e.name+&quot;:&quot;+e.message) &#125;&#125;try_it(); //ReferenceError:add is not defined 给类型增加方法123456789101112131415161718192021222324252627282930Function.prototype.method=function(name,func) &#123; this.prototype[name]=func; return this; &#125; //通过Function.prototype增加方法使得对所有函数可用 Number.method(&apos;integer&apos;,function() &#123; return Math[this &lt; 0 ? &apos;ceil&apos;:&apos;floor&apos;](this); &#125;) //Number增加一个取整方法 //ceil 向上取整， floor 向下取整 0和null的结果都是0 console.log((-5.6).integer()); //-5 console.log((5.6).integer());//5 //移除字符串末端空白的方法 String.method(&apos;trim&apos;,function() &#123; return this.replace(/^\s+|\s+$/g,&apos;&apos;) &#125;) console.log((&quot;asda dsdd &quot;).trim()+(&quot;dasdasd&quot;)); 递归（汉诺塔）作用域JavaScript不支持块级作用域，最好的做法是在函数整体顶部声明函数中可能用到的所有变量1234567891011121314151617 var foo=function() &#123; var a=3,b=5; var bar=function() &#123; var b=7,c=11; //a=3,b=7,c=11 a+=b+=c; //a=21,b=7,c=11 &#125;; //a=3,b=5,c未定义 bar(); //a=21,b=5 &#125;window.onload=function()&#123; foo();&#125; 闭包闭包是函数和声明该函数的词法环境的组合。词法作用域考虑如下情况：function init() { var name = “Mozilla”; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 } displayName();}init();init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。displayName() 是定义在&nbsp;init() 里的内部函数，仅在该函数体内可用。displayName()&nbsp;内没有自己的局部变量，然而它可以访问到外部函数的变量，所以&nbsp;displayName()&nbsp;可以使用父函数 init() 中声明的变量&nbsp;name 。但是，如果有同名变量&nbsp;name 在&nbsp;displayName()&nbsp;中被定义，则会使用&nbsp;displayName()&nbsp;中定义的&nbsp;name 。运行代码可以发现&nbsp;displayName()&nbsp;内的 alert()&nbsp;语句成功的显示了在其父函数中声明的 name 变量的值。这个词法作用域的例子介绍了引擎是如何解析函数嵌套中的变量的。词法作用域中使用的域，是变量在代码中声明的位置所决定的。嵌套的函数可以访问在其外部声明的变量。闭包现在来考虑如下例子 ：function makeFunc() { var name = “Mozilla”; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc();运行这段代码和之前的 init() 示例的效果完全一样。其中的不同 — 也是有意思的地方 — 在于内部函数 displayName() 在执行前，被外部函数返回。第一眼看上去，也许不能直观的看出这段代码能够正常运行。在一些编程语言中，函数中的局部变量仅在函数的执行期间可用。一旦 makeFunc() 执行完毕，我们会认为 name 变量将不能被访问。然而，因为代码运行得没问题，所以很显然在 JavaScript 中并不是这样的。这个谜题的答案是，JavaScript中的函数会形成闭包。 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。在我们的例子中，myFunc 是执行 makeFunc&nbsp;时创建的&nbsp;displayName 函数实例的引用，而&nbsp;displayName 实例仍可访问其词法作用域中的变量，即可以访问到 name&nbsp;。由此，当 myFunc&nbsp;被调用时，name&nbsp;仍可被访问，其值&nbsp;Mozilla&nbsp;就被传递到alert中。下面是一个更有意思的示例 — makeAdder 函数：function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x&nbsp;，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。实用的闭包闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。&nbsp;&nbsp;因此，通常你使用只有一个方法的对象的地方，都可以使用闭包。在 Web 中，你想要这样做的情况特别常见。大部分我们所写的&nbsp;JavaScript 代码都是基于事件的 — 定义某种行为，然后将其添加到用户触发的事件之上（比如点击或者按键）。我们的代码通常作为回调：为响应事件而执行的函数。假如，我们想在页面上添加一些可以调整字号的按钮。一种方法是以像素为单位指定 body 元素的 font-size，然后通过相对的 em 单位设置页面中其它元素（例如header）的字号：body { font-family: Helvetica, Arial, sans-serif; font-size: 12px;}h1 { font-size: 1.5em;}h2 { font-size: 1.2em;}我们的文本尺寸调整按钮可以修改 body 元素的 font-size 属性，由于我们使用相对单位，页面中的其它元素也会相应地调整。以下是 JavaScript：function makeSizer(size) { return function() { document.body.style.fontSize = size + ‘px’; };}var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16);size12，size14 和 size16 三个函数将分别把&nbsp;body 文本调整为 12，14，16 像素。我们可以将它们分别添加到按钮的点击事件上。如下所示：document.getElementById(‘size-12’).onclick = size12;document.getElementById(‘size-14’).onclick = size14;document.getElementById(‘size-16’).onclick = size16;&lt;a href=”#” id=”size-12”&gt;12&lt;/a&gt;&lt;a href=”#” id=”size-14”&gt;14&lt;/a&gt;&lt;a href=”#” id=”size-16”&gt;16&lt;/a&gt;用闭包模拟私有方法编程语言中，比如 Java，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。&nbsp;&nbsp;而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为 模块模式（module pattern）：var Counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } }})();console.log(Counter.value()); / logs 0 /Counter.increment();Counter.increment();console.log(Counter.value()); / logs 2 /Counter.decrement();console.log(Counter.value()); / logs 1 /在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。该共享环境创建于一个立即执行的匿名函数体内。这个环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问。这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。var makeCounter = function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } }};var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value()); / logs 0 /Counter1.increment();Counter1.increment();console.log(Counter1.value()); / logs 2 /Counter1.decrement();console.log(Counter1.value()); / logs 1 /console.log(Counter2.value()); / logs 0 /请注意两个计数器&nbsp;counter1&nbsp;和&nbsp;counter2&nbsp;是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量&nbsp;privateCounter&nbsp;。每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。在循环中创建闭包：一个常见错误在 ECMAScript 2015 引入 let 关键字 之前，在循环中有一个常见的闭包创建问题。参考下面的示例：&lt;p id=”help”&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=”text” id=”email” name=”email”&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=”text” id=”name” name=”name”&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=”text” id=”age” name=”age”&gt;&lt;/p&gt;function showHelp(help) { document.getElementById(‘help’).innerHTML = help;}function setupHelp() { var helpText = [ {‘id’: ‘email’, ‘help’: ‘Your e-mail address’}, {‘id’: ‘name’, ‘help’: ‘Your full name’}, {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’} ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } }}setupHelp();数组 helpText 中定义了三个有用的提示信息，每一个都关联于对应的文档中的input 的 ID。通过循环这三项定义，依次为相应input添加了一个 onfocus &nbsp;事件处理函数，以便显示帮助信息。运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个input上，显示的都是关于年龄的信息。原因是赋值给&nbsp;onfocus 的是闭包。这些闭包是由他们的函数定义和在&nbsp;setupHelp&nbsp;作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量item。当onfocus的回调执行时，item.help的值被决定。由于循环在事件触发之前早已执行完毕，变量对象item（被三个闭包所共享）已经指向了helpText的最后一项。解决这个问题的一种方案是使用更多的闭包：特别是使用前面所述的函数工厂：function showHelp(help) { document.getElementById(‘help’).innerHTML = help;}function makeHelpCallback(help) { return function() { showHelp(help); };}function setupHelp() { var helpText = [ {‘id’: ‘email’, ‘help’: ‘Your e-mail address’}, {‘id’: ‘name’, ‘help’: ‘Your full name’}, {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’} ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); }}setupHelp();这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的词法环境。在这些环境中，help 指向 helpText 数组中对应的字符串。另一种方法使用了匿名闭包：function showHelp(help) { document.getElementById(‘help’).innerHTML = help;}function setupHelp() { var helpText = [ {‘id’: ‘email’, ‘help’: ‘Your e-mail address’}, {‘id’: ‘name’, ‘help’: ‘Your full name’}, {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’} ]; for (var i = 0; i &lt; helpText.length; i++) { (function() { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } })(); // 马上把当前循环项的item与事件回调相关联起来 }}setupHelp();避免使用过多的闭包，可以用let关键词：function showHelp(help) { document.getElementById(‘help’).innerHTML = help;}function setupHelp() { var helpText = [ {‘id’: ‘email’, ‘help’: ‘Your e-mail address’}, {‘id’: ‘name’, ‘help’: ‘Your full name’}, {‘id’: ‘age’, ‘help’: ‘Your age (you must be over 16)’} ]; for (var i = 0; i &lt; helpText.length; i++) { let item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } }}setupHelp();这个例子使用let而不是var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。性能考量如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是，每个对象的创建）。考虑以下示例：function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };}在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype = { getName: function() { return this.name; }, getMessage: function() { return this.message; }};但我们不建议重新定义原型。可改成如下例子：function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype.getName = function() { return this.name;};MyObject.prototype.getMessage = function() { return this.message;};在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。参见 对象模型的细节 一章可以了解更为详细的信息。 知识点 1和1.0是相同的值 /运算符可能会产生一个非整数结果，即使两个运算数都是整数。 hasOwnProperty如果对象拥有独特的属性，他将返true，该方法不会检查原型链 delete会删除对象中包含的属性，不会触及原型链中任何对象]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是我的第一篇文章]]></title>
    <url>%2F2019%2F05%2F11%2F%E8%BF%99%E6%98%AF%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"></content>
      <tags>
        <tag>PS3</tag>
        <tag>Games</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
